// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'audio_playback_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AudioPlaybackFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fileNotFound,
    required TResult Function() unsupportedFormat,
    required TResult Function() invalidState,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fileNotFound,
    TResult? Function()? unsupportedFormat,
    TResult? Function()? invalidState,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fileNotFound,
    TResult Function()? unsupportedFormat,
    TResult Function()? invalidState,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FileNotFound value) fileNotFound,
    required TResult Function(UnsupportedFormat value) unsupportedFormat,
    required TResult Function(InvalidState value) invalidState,
    required TResult Function(Unknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FileNotFound value)? fileNotFound,
    TResult? Function(UnsupportedFormat value)? unsupportedFormat,
    TResult? Function(InvalidState value)? invalidState,
    TResult? Function(Unknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FileNotFound value)? fileNotFound,
    TResult Function(UnsupportedFormat value)? unsupportedFormat,
    TResult Function(InvalidState value)? invalidState,
    TResult Function(Unknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioPlaybackFailureCopyWith<$Res> {
  factory $AudioPlaybackFailureCopyWith(AudioPlaybackFailure value,
          $Res Function(AudioPlaybackFailure) then) =
      _$AudioPlaybackFailureCopyWithImpl<$Res, AudioPlaybackFailure>;
}

/// @nodoc
class _$AudioPlaybackFailureCopyWithImpl<$Res,
        $Val extends AudioPlaybackFailure>
    implements $AudioPlaybackFailureCopyWith<$Res> {
  _$AudioPlaybackFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FileNotFoundCopyWith<$Res> {
  factory _$$FileNotFoundCopyWith(
          _$FileNotFound value, $Res Function(_$FileNotFound) then) =
      __$$FileNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FileNotFoundCopyWithImpl<$Res>
    extends _$AudioPlaybackFailureCopyWithImpl<$Res, _$FileNotFound>
    implements _$$FileNotFoundCopyWith<$Res> {
  __$$FileNotFoundCopyWithImpl(
      _$FileNotFound _value, $Res Function(_$FileNotFound) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FileNotFound implements FileNotFound {
  const _$FileNotFound();

  @override
  String toString() {
    return 'AudioPlaybackFailure.fileNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FileNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fileNotFound,
    required TResult Function() unsupportedFormat,
    required TResult Function() invalidState,
    required TResult Function() unknown,
  }) {
    return fileNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fileNotFound,
    TResult? Function()? unsupportedFormat,
    TResult? Function()? invalidState,
    TResult? Function()? unknown,
  }) {
    return fileNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fileNotFound,
    TResult Function()? unsupportedFormat,
    TResult Function()? invalidState,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (fileNotFound != null) {
      return fileNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FileNotFound value) fileNotFound,
    required TResult Function(UnsupportedFormat value) unsupportedFormat,
    required TResult Function(InvalidState value) invalidState,
    required TResult Function(Unknown value) unknown,
  }) {
    return fileNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FileNotFound value)? fileNotFound,
    TResult? Function(UnsupportedFormat value)? unsupportedFormat,
    TResult? Function(InvalidState value)? invalidState,
    TResult? Function(Unknown value)? unknown,
  }) {
    return fileNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FileNotFound value)? fileNotFound,
    TResult Function(UnsupportedFormat value)? unsupportedFormat,
    TResult Function(InvalidState value)? invalidState,
    TResult Function(Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (fileNotFound != null) {
      return fileNotFound(this);
    }
    return orElse();
  }
}

abstract class FileNotFound implements AudioPlaybackFailure {
  const factory FileNotFound() = _$FileNotFound;
}

/// @nodoc
abstract class _$$UnsupportedFormatCopyWith<$Res> {
  factory _$$UnsupportedFormatCopyWith(
          _$UnsupportedFormat value, $Res Function(_$UnsupportedFormat) then) =
      __$$UnsupportedFormatCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnsupportedFormatCopyWithImpl<$Res>
    extends _$AudioPlaybackFailureCopyWithImpl<$Res, _$UnsupportedFormat>
    implements _$$UnsupportedFormatCopyWith<$Res> {
  __$$UnsupportedFormatCopyWithImpl(
      _$UnsupportedFormat _value, $Res Function(_$UnsupportedFormat) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnsupportedFormat implements UnsupportedFormat {
  const _$UnsupportedFormat();

  @override
  String toString() {
    return 'AudioPlaybackFailure.unsupportedFormat()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UnsupportedFormat);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fileNotFound,
    required TResult Function() unsupportedFormat,
    required TResult Function() invalidState,
    required TResult Function() unknown,
  }) {
    return unsupportedFormat();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fileNotFound,
    TResult? Function()? unsupportedFormat,
    TResult? Function()? invalidState,
    TResult? Function()? unknown,
  }) {
    return unsupportedFormat?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fileNotFound,
    TResult Function()? unsupportedFormat,
    TResult Function()? invalidState,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unsupportedFormat != null) {
      return unsupportedFormat();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FileNotFound value) fileNotFound,
    required TResult Function(UnsupportedFormat value) unsupportedFormat,
    required TResult Function(InvalidState value) invalidState,
    required TResult Function(Unknown value) unknown,
  }) {
    return unsupportedFormat(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FileNotFound value)? fileNotFound,
    TResult? Function(UnsupportedFormat value)? unsupportedFormat,
    TResult? Function(InvalidState value)? invalidState,
    TResult? Function(Unknown value)? unknown,
  }) {
    return unsupportedFormat?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FileNotFound value)? fileNotFound,
    TResult Function(UnsupportedFormat value)? unsupportedFormat,
    TResult Function(InvalidState value)? invalidState,
    TResult Function(Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unsupportedFormat != null) {
      return unsupportedFormat(this);
    }
    return orElse();
  }
}

abstract class UnsupportedFormat implements AudioPlaybackFailure {
  const factory UnsupportedFormat() = _$UnsupportedFormat;
}

/// @nodoc
abstract class _$$InvalidStateCopyWith<$Res> {
  factory _$$InvalidStateCopyWith(
          _$InvalidState value, $Res Function(_$InvalidState) then) =
      __$$InvalidStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InvalidStateCopyWithImpl<$Res>
    extends _$AudioPlaybackFailureCopyWithImpl<$Res, _$InvalidState>
    implements _$$InvalidStateCopyWith<$Res> {
  __$$InvalidStateCopyWithImpl(
      _$InvalidState _value, $Res Function(_$InvalidState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InvalidState implements InvalidState {
  const _$InvalidState();

  @override
  String toString() {
    return 'AudioPlaybackFailure.invalidState()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InvalidState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fileNotFound,
    required TResult Function() unsupportedFormat,
    required TResult Function() invalidState,
    required TResult Function() unknown,
  }) {
    return invalidState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fileNotFound,
    TResult? Function()? unsupportedFormat,
    TResult? Function()? invalidState,
    TResult? Function()? unknown,
  }) {
    return invalidState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fileNotFound,
    TResult Function()? unsupportedFormat,
    TResult Function()? invalidState,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (invalidState != null) {
      return invalidState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FileNotFound value) fileNotFound,
    required TResult Function(UnsupportedFormat value) unsupportedFormat,
    required TResult Function(InvalidState value) invalidState,
    required TResult Function(Unknown value) unknown,
  }) {
    return invalidState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FileNotFound value)? fileNotFound,
    TResult? Function(UnsupportedFormat value)? unsupportedFormat,
    TResult? Function(InvalidState value)? invalidState,
    TResult? Function(Unknown value)? unknown,
  }) {
    return invalidState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FileNotFound value)? fileNotFound,
    TResult Function(UnsupportedFormat value)? unsupportedFormat,
    TResult Function(InvalidState value)? invalidState,
    TResult Function(Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (invalidState != null) {
      return invalidState(this);
    }
    return orElse();
  }
}

abstract class InvalidState implements AudioPlaybackFailure {
  const factory InvalidState() = _$InvalidState;
}

/// @nodoc
abstract class _$$UnknownCopyWith<$Res> {
  factory _$$UnknownCopyWith(_$Unknown value, $Res Function(_$Unknown) then) =
      __$$UnknownCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnknownCopyWithImpl<$Res>
    extends _$AudioPlaybackFailureCopyWithImpl<$Res, _$Unknown>
    implements _$$UnknownCopyWith<$Res> {
  __$$UnknownCopyWithImpl(_$Unknown _value, $Res Function(_$Unknown) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Unknown implements Unknown {
  const _$Unknown();

  @override
  String toString() {
    return 'AudioPlaybackFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fileNotFound,
    required TResult Function() unsupportedFormat,
    required TResult Function() invalidState,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? fileNotFound,
    TResult? Function()? unsupportedFormat,
    TResult? Function()? invalidState,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fileNotFound,
    TResult Function()? unsupportedFormat,
    TResult Function()? invalidState,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FileNotFound value) fileNotFound,
    required TResult Function(UnsupportedFormat value) unsupportedFormat,
    required TResult Function(InvalidState value) invalidState,
    required TResult Function(Unknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FileNotFound value)? fileNotFound,
    TResult? Function(UnsupportedFormat value)? unsupportedFormat,
    TResult? Function(InvalidState value)? invalidState,
    TResult? Function(Unknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FileNotFound value)? fileNotFound,
    TResult Function(UnsupportedFormat value)? unsupportedFormat,
    TResult Function(InvalidState value)? invalidState,
    TResult Function(Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class Unknown implements AudioPlaybackFailure {
  const factory Unknown() = _$Unknown;
}
